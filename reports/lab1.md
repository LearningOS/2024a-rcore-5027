## 功能
添加了一个syscall_count 方法去实现计数，在每次调用syscall的时候都会先进行计数。
然后在find_next和run_first的方法中增加了一个计时器，并且增加了一个对应的变量来存储。通过返回计时器的值来计算run_time，因为有些任务可能没有开始，所以使用的是option<>。任务状态则直接通过在taskmanager中通过访问taskcontrolblock实现。

## 问答题
1. 版本是RustSBI version 0.3.0-alpha.2, adapting to RISC-V SBI v1.0.0，第一个一异常是因为访问了一个不存在的地址，第二个异常是在用户态却调用了一个从S切换到U状态的函数sret，所以导致报错，第三个异常是因为当前是U状态，但是却访问了s状态的csr——sstatus.
2. 
      1. a0指的是之前内核态的栈指针，来完成特权级切换时候的换栈操作。__restore用于任务切换或者处理trap的时候从内核态返回到用户态
      2. 特殊处理了sstatus，sepc，和sscratch几个寄存器，sstatus保存了当前处理器的特权级信息，sepc是一个程序计数器，保存了trap发生时的指令地址， sscratch 保存了 Trap 发生前的栈指针 sp
      3. 因为x2对应的是栈指针sp，而x4对应的是线程指针tp
      4. 把sp和sscratch的值相互交换，进行换栈操作，让sp指向用户栈栈顶
      5. sret指令，通过修改sstatus的值来切换特权级，并且加载sepc中的指令
      6. 再次交换sp和sscratch的值，使得sp重新指向内核态栈顶
      7. ecall指令
3.  1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：
    
    暂无

   此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

   暂无

   2. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

   3. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。